<!-- Content generated/inserted by enhance_courseware.py -->
<div class="text-base md:text-lg">
  <h2 class="text-3xl lg:text-4xl font-bold text-white mb-6">
    The "Why" Behind the "What": HTMX Core Concepts
  </h2>
  <div x-data="{ openAccordion: 1 }" class="space-y-3 text-left">
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 1">
      <summary @click.prevent="openAccordion = (openAccordion === 1) ? null : 1" class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center">
        <span>Why use `hx-swap`? (The Set Change)</span>
        <span class="text-slate-500 text-sm transform transition-transform" :class="{ 'rotate-180': openAccordion === 1 }">▼</span>
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> You need to update a piece of the UI. Traditionally, you'd write JavaScript to fetch new data, then manually find the target element and decide how to update it (e.g., `element.innerHTML = ...`, `element.replaceWith(...)`, `element.append(...)`). This is repetitive and mixes presentation logic into your scripts.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> `hx-swap` lets you declaratively state *how* the server's response should be placed into the DOM. Whether you want to replace an element's inner content (`innerHTML`), the entire element itself (`outerHTML`), or add to it (`beforeend`, `afterend`), you just specify it in the HTML. It's like telling your crew "put the painting *inside* the frame" versus "replace the *entire* fireplace".
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 2">
      <summary @click.prevent="openAccordion = (openAccordion === 2) ? null : 2" class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center">
        <span>Why use `hx-select`? (The Prop Request)</span>
        <span class="text-slate-500 text-sm transform transition-transform" :class="{ 'rotate-180': openAccordion === 2 }">▼</span>
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> An API endpoint returns a large block of HTML, but you only need one specific part of it for your update. In vanilla JS, you'd have to fetch the entire response, parse it into a DOM fragment, use `querySelector` to find the piece you need, and then inject it. This is inefficient and clunky.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> `hx-select` acts like a filter. You provide a CSS selector (e.g., `#antique-telephone`), and HTMX will fetch the full response from the server but only extract and swap the matching element. It's like asking your prop master for "the antique telephone from the inventory room" instead of having them bring the entire room to the stage.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 3">
      <summary @click.prevent="openAccordion = (openAccordion === 3) ? null : 3" class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center">
        <span>Why use `hx-post` on a form? (The Workshop Order)</span>
        <span class="text-slate-500 text-sm transform transition-transform" :class="{ 'rotate-180': openAccordion === 3 }">▼</span>
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> Submitting a form with AJAX requires writing JavaScript to prevent the default full-page submission, manually gathering all the form's input values, constructing a `FormData` object, and configuring a `fetch` POST request. This is a lot of boilerplate for a very common task.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> Placing `hx-post` on a `<form>` tag is all you need. HTMX automatically intercepts the form submission, includes all named inputs in the request, and sends it to your server via AJAX. It's the "it just works" solution for modern forms.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 4">
      <summary @click.prevent="openAccordion = (openAccordion === 4) ? null : 4" class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center">
        <span>Why use `HX-Trigger`? (The Director's Cue)</span>
        <span class="text-slate-500 text-sm transform transition-transform" :class="{ 'rotate-180': openAccordion === 4 }">▼</span>
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> A server response needs to do more than just swap HTML. It might need to trigger a notification, refresh another component, or interact with a third-party script. You would typically return complex JSON and write a "controller" in JavaScript to interpret the response and call different functions.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> The server can include an `HX-Trigger` header in its response, naming one or more client-side events (e.g., `flash-lights`, `play-sound`). HTMX will then dispatch these events. Other elements on the page (or a library like Alpine.js) can simply listen for these events and react, completely decoupling the effect from the initial request. It's the server "cueing" the lighting and sound boards to act independently.
        </p>
      </div>
    </details>
  </div>
</div>
<button @click="conceptsModalOpen = false" class="absolute top-4 right-4 text-slate-500 hover:text-slate-300 text-3xl font-light">
  ×
</button>