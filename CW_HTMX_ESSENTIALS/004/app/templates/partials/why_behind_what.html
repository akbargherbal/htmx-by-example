<!-- Content generated/inserted by enhance_courseware.py -->
<div class="text-base md:text-lg">
  <h2 class="text-3xl lg:text-4xl font-bold text-white mb-6">
    The "Why" Behind the "What": HTMX Concepts
  </h2>
  <div x-data="{ openAccordion: 1 }" class="space-y-3 text-left">
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 1">
      <summary
        @click.prevent="openAccordion = (openAccordion === 1) ? null : 1"
        class="font-semibold text-lg lg:text-xl text-indigo-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-trigger="every 5s"` for Polling?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 1 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> To create a live-updating element like our fuel gauge, you'd typically need to write JavaScript using `setInterval`. This involves managing the timer, writing a `fetch` request, handling the response, and manually updating the DOM, all while ensuring the timer is cleaned up properly.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> The `hx-trigger` attribute completely replaces this manual JavaScript. By setting it to `every 5s`, we instruct HTMX to handle the entire polling loop—making the request and swapping the response—declaratively in our HTML. It's concise, readable, and requires zero custom scripting for the core functionality.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 2">
      <summary
        @click.prevent="openAccordion = (openAccordion === 2) ? null : 2"
        class="font-semibold text-lg lg:text-xl text-indigo-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-post` on a Form?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 2 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> Handling form submissions without a full page reload requires JavaScript. You need to add an event listener, prevent the default submission, serialize the form data (including all inputs and checkboxes), make an AJAX `POST` request, and then update a part of the page with the server's response.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> Placing `hx-post` on the `<form>` tag automates this entire process. HTMX automatically listens for the submit event, gathers all named input values (like `destination` and `avoid_tolls`), sends them in the request body, and swaps the HTML response into the `hx-target`.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 3">
      <summary
        @click.prevent="openAccordion = (openAccordion === 3) ? null : 3"
        class="font-semibold text-lg lg:text-xl text-indigo-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use the `htmx:responseError` Event?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 3 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> In a large application, every AJAX request needs its own error handling logic (`if (!response.ok)` or a `.catch()` block). This leads to repetitive code and makes it difficult to implement a consistent, application-wide error display strategy.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> HTMX emits a `htmx:responseError` event for any request that doesn't return a 2xx status code. By adding a single event listener to the `body`, we can intercept all errors from any HTMX request on the page. This allows us to create a centralized, robust error handling system (like our Alert Panel) with minimal code.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 4">
      <summary
        @click.prevent="openAccordion = (openAccordion === 4) ? null : 4"
        class="font-semibold text-lg lg:text-xl text-indigo-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use the `HX-Redirect` Header?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 4 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> Sometimes a server needs to force the client to navigate to a new page (e.g., after a successful login or, in our case, to enforce a workflow). A standard HTTP 302 redirect causes a full page reload. To do this smoothly in a client-side app, the server would need to send a special JSON response, and the JavaScript would need to parse it and call `window.location.href`.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> The server can simply respond to an HTMX request with a special `HX-Redirect` header containing a URL. HTMX automatically detects this header and performs the client-side redirect for you. This keeps the logic on the server, where it belongs, and requires no custom JavaScript on the client.
        </p>
      </div>
    </details>
  </div>
</div>
<button
  @click="conceptsModalOpen = false"
  class="absolute top-4 right-4 text-slate-500 hover:text-slate-300 text-3xl font-light"
>
  ×
</button>