<!-- Content generated/inserted by enhance_courseware.py -->
<div class="text-base md:text-lg">
  <h2 class="text-3xl lg:text-4xl font-bold text-white mb-6">
    The "Why" Behind the "What": HTMX Core Concepts
  </h2>
  <div x-data="{ openAccordion: 1 }" class="space-y-3 text-left">
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 1">
      <summary
        @click.prevent="openAccordion = (openAccordion === 1) ? null : 1"
        class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-get`, `hx-post`, `hx-put`, `hx-delete`?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 1 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> To fetch or submit data without a full page reload, you traditionally need to write JavaScript. This involves using the `fetch()` API, setting the correct HTTP method, handling headers, serializing form data for POST requests, and then parsing the response to update the page. This is boilerplate code that you have to repeat for every dynamic interaction.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> HTMX provides attributes that map directly to HTTP verbs. By adding `hx-get="/api/..."` or `hx-post="/api/..."` to an element, you tell HTMX to handle the entire AJAX request cycle for you. It automatically performs the request and swaps the response into the page, eliminating the need for custom JavaScript for most common web interactions.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 2">
      <summary
        @click.prevent="openAccordion = (openAccordion === 2) ? null : 2"
        class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-target`?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 2 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> After your JavaScript `fetch()` call gets a response, you need to decide where on the page the new content should go. This requires writing more JavaScript to select a DOM element, for example, using `document.getElementById('some-id')`, and then manually inserting the content. This couples your script logic to your HTML structure.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> The `hx-target` attribute lets you declare where the response should be placed, right in your HTML. You provide a CSS selector (like `#serving-plate` or `this`) and HTMX handles finding that element and updating it for you. This keeps the action (the button) and its intended result (the target) co-located and easy to understand.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 3">
      <summary
        @click.prevent="openAccordion = (openAccordion === 3) ? null : 3"
        class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-swap`?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 3 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> Simply putting new content inside an element (`innerHTML`) isn't always what you want. Sometimes you need to replace the element itself (like when deleting an item), or append content. In JavaScript, this requires different DOM manipulation methods (`element.outerHTML = ...`, `element.remove()`, `element.append()`), adding more complexity.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> `hx-swap` gives you fine-grained control over *how* the content is placed. The default is `innerHTML`, but you can use `outerHTML` to replace the target element entirely (as seen with the "Throw Away Toast" button), or other values like `beforeend` to append. It's a declarative way to specify the exact DOM update you need.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 4">
      <summary
        @click.prevent="openAccordion = (openAccordion === 4) ? null : 4"
        class="font-semibold text-lg lg:text-xl text-teal-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-trigger`?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 4 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> Not all requests should be triggered by a click. You might want to update data when a user types, or automatically poll a server for status updates. This requires writing JavaScript to set up event listeners (`element.addEventListener('keyup', ...)` or timers (`setInterval(...)`), which adds more complexity and state to manage.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> `hx-trigger` lets you specify what event should cause the request. While it defaults to a `click` for buttons, you can use any browser event. More powerfully, you can use modifiers like `hx-trigger="every 2s"` to create a polling mechanism (as seen in the "Chef's Status" monitor) with a single, simple attribute.
        </p>
      </div>
    </details>
  </div>
</div>
<button
  @click="conceptsModalOpen = false"
  class="absolute top-4 right-4 text-slate-500 hover:text-slate-300 text-3xl font-light"
>
  ×
</button>