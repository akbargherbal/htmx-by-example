<!-- Content generated/inserted by enhance_courseware.py -->
<div class="text-base md:text-lg">
  <h2 class="text-3xl lg:text-4xl font-bold text-white mb-6">
    The "Why" Behind the "What": HTMX Core Concepts
  </h2>
  <div x-data="{ openAccordion: 1 }" class="space-y-3 text-left">
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 1">
      <summary
        @click.prevent="openAccordion = (openAccordion === 1) ? null : 1"
        class="font-semibold text-lg lg:text-xl text-indigo-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-include`?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 1 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> A form needs to submit its own data, plus other information from a different part of the page (like a user ID from a profile header). Without HTMX, you'd need JavaScript to manually find these extra elements, get their values, and combine everything before making an AJAX request.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> The `hx-include` attribute lets you provide a CSS selector (e.g., `#customer-info`). When the request is made, HTMX automatically finds that element and includes the values of any input fields inside it, merging them with the main form's data. It's a declarative way to aggregate data from anywhere on the page.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 2">
      <summary
        @click.prevent="openAccordion = (openAccordion === 2) ? null : 2"
        class="font-semibold text-lg lg:text-xl text-indigo-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why use `hx-vals`?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 2 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> You need to send a static piece of data to the server that isn't entered by the user and doesn't have a dedicated input field. For example, sending `service_type: "Express"`. The traditional solution is to add a `<input type="hidden">`, which clutters the DOM.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> `hx-vals` allows you to add extra key-value pairs to the request directly in the HTML, using a JSON-like string (e.g., `hx-vals='{"service_type": "Express"}'`). This keeps the data right where the action is triggered and avoids adding unnecessary hidden elements to your markup.
        </p>
      </div>
    </details>
    <details class="bg-slate-900 p-4 rounded-lg" :open="openAccordion === 3">
      <summary
        @click.prevent="openAccordion = (openAccordion === 3) ? null : 3"
        class="font-semibold text-lg lg:text-xl text-indigo-400 cursor-pointer list-none flex justify-between items-center"
      >
        <span>Why handle server responses this way?</span>
        <span
          class="text-slate-500 text-sm transform transition-transform"
          :class="{ 'rotate-180': openAccordion === 3 }"
          >▼</span
        >
      </summary>
      <div class="mt-3 text-slate-300 space-y-2">
        <p>
          <strong>The Problem:</strong> A web application must handle success (HTTP 200), client errors (like 404 Not Found), and server errors (like 500 Internal Server Error). In JavaScript, this often means writing separate logic in `.then()` and `.catch()` blocks to update the UI differently for each case.
        </p>
        <p>
          <strong>The HTMX Solution:</strong> HTMX simplifies this by letting the server control the UI for all outcomes. The backend returns a snippet of HTML along with the appropriate status code (200, 404, 500, etc.). HTMX receives this response and, by default, swaps the HTML into the target regardless of the status. This means your backend can generate a success message, a "not found" error, or a "server down" warning, and the frontend will render it using the exact same `hx-post`/`hx-target` mechanism.
        </p>
      </div>
    </details>
  </div>
</div>
<button
  @click="conceptsModalOpen = false"
  class="absolute top-4 right-4 text-slate-500 hover:text-slate-300 text-3xl font-light"
>
  ×
</button>